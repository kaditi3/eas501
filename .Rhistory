import numpy as np
# Initialize population data and parameters
time_steps = 500
lynx_population = np.zeros(time_steps + 1)
hare_population = np.zeros(time_steps + 1)
lynx_population[0] = hare_population[0] = 1.1
# Define the interaction functions
def f_func(prey, a, b):
return a - b * prey
def g_func(predator, c, d):
return c * predator - d
# Basic iteration over the population data
for i in range(time_steps):
lynx_population[i + 1] = lynx_population[i] + lynx_population[i] * f_func(hare_population[i], 0.01, 0.01)
hare_population[i + 1] = hare_population[i] + hare_population[i] * g_func(lynx_population[i], 0.01, 0.01)
import numpy as np
# Initialize population data and parameters
time_steps = 500
lynx_population = np.zeros(time_steps + 1)
hare_population = np.zeros(time_steps + 1)
lynx_population[0] = hare_population[0] = 1.1
# Define the interaction functions
def f_func(prey, a, b):
return a - b * prey
def g_func(predator, c, d):
return c * predator - d
# Basic iteration over the population data
for i in range(time_steps):
lynx_population[i + 1] = lynx_population[i] + lynx_population[i] * f_func(hare_population[i], 0.01, 0.01)
hare_population[i + 1] = hare_population[i] + hare_population[i] * g_func(lynx_population[i], 0.01, 0.01)
import matplotlib.pyplot as plt
# Time series plot showing population changes
plt.plot(range(time_steps + 1), lynx_population, label='lynx', color='blue')
plt.plot(range(time_steps + 1), hare_population, label='hare', color='red')
plt.xlabel('Time')
plt.ylabel('Population')
plt.legend(title='Species')
plt.title('Population dynamics over time')
plt.show()
plt.show()
import numpy as np
# Initialize population data and parameters
time_steps = 500
lynx_population = np.zeros(time_steps + 1)
hare_population = np.zeros(time_steps + 1)
lynx_population[0] = hare_population[0] = 1.1
# Define the interaction functions
def f_func(prey, a, b):
return a - b * prey
def g_func(predator, c, d):
return c * predator - d
# Basic iteration over the population data
for i in range(time_steps):
lynx_population[i + 1] = lynx_population[i] + lynx_population[i] * f_func(hare_population[i], 0.01, 0.01)
hare_population[i + 1] = hare_population[i] + hare_population[i] * g_func(lynx_population[i], 0.01, 0.01)
import matplotlib.pyplot as plt
import numpy as np
# Initialize population data and parameters
time_steps = 500
lynx_population = np.zeros(time_steps + 1)
hare_population = np.zeros(time_steps + 1)
lynx_population[0] = hare_population[0] = 1.1
# Define the interaction functions
def f_func(prey, a, b):
return a - b * prey
def g_func(predator, c, d):
return c * predator - d
# Basic iteration over the population data
for i in range(time_steps):
lynx_population[i + 1] = lynx_population[i] + lynx_population[i] * f_func(hare_population[i], 0.01, 0.01)
hare_population[i + 1] = hare_population[i] + hare_population[i] * g_func(lynx_population[i], 0.01, 0.01)
import numpy as np
# Initialize population data and parameters
time_steps = 500
lynx_population = np.zeros(time_steps + 1)
hare_population = np.zeros(time_steps + 1)
lynx_population[0] = hare_population[0] = 1.1
# Define the interaction functions
def f_func(prey, a, b):
return a - b * prey
def g_func(predator, c, d):
return c * predator - d
# Basic iteration over the population data
for i in range(time_steps):
lynx_population[i + 1] = lynx_population[i] + lynx_population[i] * f_func(hare_population[i], 0.01, 0.01)
hare_population[i + 1] = hare_population[i] + hare_population[i] * g_func(lynx_population[i], 0.01, 0.01)
import numpy as np
# Initialize population data and parameters
time_steps = 500
lynx_population = np.zeros(time_steps + 1)
hare_population = np.zeros(time_steps + 1)
lynx_population[0] = hare_population[0] = 1.1
# Define the interaction functions
def f_func(prey, a, b):
return a - b * prey
def g_func(predator, c, d):
return c * predator - d
# Basic iteration over the population data
for i in range(time_steps):
lynx_population[i + 1] = lynx_population[i] + lynx_population[i] * f_func(hare_population[i], 0.01, 0.01)
hare_population[i + 1] = hare_population[i] + hare_population[i] * g_func(lynx_population[i], 0.01, 0.01)
import numpy as np
# Initialize population data and parameters
time_steps = 500
lynx_population = np.zeros(time_steps + 1)
hare_population = np.zeros(time_steps + 1)
lynx_population[0] = hare_population[0] = 1.1
# Define the interaction functions
def f_func(prey, a, b):
return a - b * prey
def g_func(predator, c, d):
return c * predator - d
# Basic iteration over the population data
for i in range(time_steps):
lynx_population[i + 1] = lynx_population[i] + lynx_population[i] * f_func(hare_population[i], 0.01, 0.01)
hare_population[i + 1] = hare_population[i] + hare_population[i] * g_func(lynx_population[i], 0.01, 0.01)
import matplotlib.pyplot as plt
# Time series plot showing population changes
plt.plot(range(time_steps + 1), lynx_population, label='lynx', color='blue')
plt.plot(range(time_steps + 1), hare_population, label='hare', color='red')
plt.xlabel('Time')
plt.ylabel('Population')
plt.legend(title='Species')
plt.title('Population dynamics over time')
plt.show()
plt.show()
import numpy as np
# Initialize population data and parameters
time_steps = 500
lynx_population = np.zeros(time_steps + 1)
hare_population = np.zeros(time_steps + 1)
lynx_population[0] = hare_population[0] = 1.1
def f_func(prey, a, b):
return a - b * prey
def g_func(predator, c, d):
return c * predator - d
# Basic iteration over the population data
for i in range(time_steps):
lynx_population[i + 1] = lynx_population[i] + lynx_population[i] * f_func(hare_population[i], 0.01, 0.01)
hare_population[i + 1] = hare_population[i] + hare_population[i] * g_func(lynx_population[i], 0.01, 0.01)
import matplotlib.pyplot as plt
# Time series plot showing population changes
plt.plot(range(time_steps + 1), lynx_population, label='lynx', color='blue')
plt.plot(range(time_steps + 1), hare_population, label='hare', color='red')
plt.xlabel('Time')
plt.ylabel('Population')
plt.legend(title='Species')
plt.title('Population dynamics over time')
plt.show()
import numpy as np
# Initialize population data and parameters
time_steps = 500
lynx_population = np.zeros(time_steps + 1)
hare_population = np.zeros(time_steps + 1)
lynx_population[0] = hare_population[0] = 1.1
# Define the interaction functions
def f_func(prey, a, b):
return a - b * prey
def g_func(predator, c, d):
return c * predator - d
# Basic iteration over the population data
for i in range(time_steps):
lynx_population[i + 1] = lynx_population[i] + lynx_population[i] * f_func(hare_population[i], 0.01, 0.01)
hare_population[i + 1] = hare_population[i] + hare_population[i] * g_func(lynx_population[i], 0.01, 0.01)
import matplotlib.pyplot as plt
# Time series plot showing population changes
plt.plot(range(time_steps + 1), lynx_population, label='lynx', color='blue')
plt.plot(range(time_steps + 1), hare_population, label='hare', color='red')
plt.xlabel('Time')
plt.ylabel('Population')
plt.legend(title='Species')
plt.title('Population dynamics over time')
plt.show()
import numpy as np
# Initialize population data and parameters
time_steps = 500
lynx_population = np.zeros(time_steps + 1)
hare_population = np.zeros(time_steps + 1)
lynx_population[0] = hare_population[0] = 1.1
# Define the interaction functions
def f_func(prey, a, b):
return a - b * prey
def g_func(predator, c, d):
return c * predator - d
# Basic iteration over the population data
for i in range(time_steps):
lynx_population[i + 1] = lynx_population[i] + lynx_population[i] * f_func(hare_population[i], 0.01, 0.01)
hare_population[i + 1] = hare_population[i] + hare_population[i] * g_func(lynx_population[i], 0.01, 0.01)
import matplotlib.pyplot as plt
# Time series plot showing population changes
plt.plot(range(time_steps + 1), lynx_population, label='lynx', color='blue')
plt.plot(range(time_steps + 1), hare_population, label='hare', color='red')
plt.xlabel('Time')
plt.ylabel('Population')
plt.legend(title='Species')
plt.title('Population dynamics over time')
plt.show()
import numpy as np
# Initialize population data and parameters
time_steps = 500
lynx_population = np.zeros(time_steps + 1)
hare_population = np.zeros(time_steps + 1)
lynx_population[0] = hare_population[0] = 1.1
def f_func(prey, a, b):
return a - b * prey
def g_func(predator, c, d):
return c * predator - d
# Basic iteration over the population data
for i in range(time_steps):
lynx_population[i + 1] = lynx_population[i] + lynx_population[i] * f_func(hare_population[i], 0.01, 0.01)
hare_population[i + 1] = hare_population[i] + hare_population[i] * g_func(lynx_population[i], 0.01, 0.01)
import matplotlib.pyplot as plt
import matplotlib.pyplot as plt
import matplotlib.pyplot as plt
import matplotlib
import matplotlib.pyplot as plt
import matplotlib
temps_fahrenheit = [32, 68, 77, 104]
temps_celsius = []
for temp in temps_fahrenheit:
celsius = (temp - 32) * (5 / 9)
temps_celsius.append(celsius)
print(temps_celsius)
# Functional approach using map
temps_fahrenheit = [32, 68, 77, 104]
temps_celsius = list(map(lambda f: (f - 32) * (5 / 9), temps_fahrenheit))
print(temps_celsius)
import numpy as np
# Initialize population data with NumPy arrays
time_steps = 500
lynx_population = np.zeros(time_steps + 1)
hare_population = np.zeros(time_steps + 1)
lynx_population[0] = hare_population[0] = 1.1
# Vectorized simulation
lynx_change = np.zeros(time_steps)
hare_change = np.zeros(time_steps)
# Calculate changes with vectorized operations
lynx_change = 0.01 - 0.01 * hare_population[:-1]
hare_change = 0.01 * lynx_population[:-1] - 0.01
# Apply cumulative product to simulate population changes
lynx_population[1:] = lynx_population[0] * np.cumprod(1 + lynx_change)
hare_population[1:] = hare_population[0] * np.cumprod(1 + hare_change)
time_steps = 500
library(reticulate)
# Create a new Python virtual environment
virtualenv_create("r-reticulate")
# Install Python packages in the virtual environment
virtualenv_install("r-reticulate", packages = c("requests", "pandas"))
# Define the discrete exponential growth model function
run_exponential_growth <- function(N0 = 1, lambda = 1.1, time = 100) {
# Validate inputs
if (!(length(N0) == 1 & is.numeric(N0))) stop("N0 should be a single number")
if (!(length(lambda) == 1 & is.numeric(lambda))) stop("lambda should be a single number")
if (!(length(time) == 1 & is.numeric(time))) stop("time should be a single number")
# Calculate population growth over time
to_return <- c(N0, N0 * (lambda^(1:time)))
to_return_df <- data.frame(time = 0:time, Nt = to_return)
return(to_return_df)
}
test_growth <- run_exponential_growth(N0 = 1, lambda = 1.2, time = 10)
print(test_growth)
print(test_growth)
plot_exponential_growth <- function(data) {
plot(data$time, data$Nt,
type = "o", col = "blue", ylim = c(0, max(data$Nt)),
xlab = "Time", ylab = "Population size", main = "Population growth over time"
)
}
plot_exponential_growth(test_growth)
server <- function(input, output) {
sim_data <- reactive({
run_exponential_growth(N0 = input$N0, lambda = input$lambda, time = input$time)
})
output$growthPlot <- renderPlot({
plot_exponential_growth(sim_data())
})
}
# Run the application
shinyApp(ui = ui, server = server)
server <- function(input, output) {
sim_data <- reactive({
run_exponential_growth(N0 = input$N0, lambda = input$lambda, time = input$time)
})
output$growthPlot <- renderPlot({
plot_exponential_growth(sim_data())
})
}
# Run the application
shinyApp(ui = ui, server = server)
# Define server logic
server <- function(input, output) {
sim_data <- reactive({
run_exponential_growth(N0 = input$N0, lambda = input$lambda, time = input$time)
})
output$growthPlot <- renderPlot({
plot_exponential_growth(sim_data())
})
}
sim_data <- reactive({
run_exponential_growth(N0 = input$N0, lambda = input$lambda, time = input$time)
})
output$growthPlot <- renderPlot({
plot_exponential_growth(sim_data())
})
# Define server logic
server <- function(input, output) {
sim_data <- reactive({
run_exponential_growth(N0 = input$N0, lambda = input$lambda, time = input$time)
})
output$growthPlot <- renderPlot({
plot_exponential_growth(sim_data())
})
}
# Run the application
shinyApp(ui = ui, server = server)
# Run the application
shinyApp(ui = ui, server = server)
library(shiny)
install.packages("shiny")
library(shiny)
# Define UI
ui <- fluidPage(
titlePanel("Exponential growth model"),
sidebarLayout(
mainPanel(
plotOutput("growthPlot")
),
sidebarPanel(
sliderInput("lambda", "Population growth rate (lambda):",
min = 0.01, max = 2, value = 1.1, step = 0.01
),
numericInput("N0", "Initial population size (N0):", value = 1, min = 0.1, step = 0.1),
numericInput("time", "Number of time steps to project:", value = 30, min = 1)
)
)
)
server <- function(input, output) {
sim_data <- reactive({
run_exponential_growth(N0 = input$N0, lambda = input$lambda, time = input$time)
})
output$growthPlot <- renderPlot({
plot_exponential_growth(sim_data())
})
}
# Run the application
shinyApp(ui = ui, server = server)
library(reticulate)
library(shiny)
shinyApp(ui = ui, server = server)
library(reticulate)
library(shiny)
virtualenv_create("r-reticulate")
virtualenv_install("r-reticulate", packages = c("requests", "pandas"))
run_logistic_growth <- function(N0 = 1, r = 0.1, K =10, time = 100) {
if (!(length(N0) == 1 & is.numeric(N0))) stop("N0 should be a single number")
if (!(length(r) == 1 & is.numeric(r))) stop("r should be a single number")
if (!(length(K) == 1 & is.numeric(K))) stop("K should be a single number")
if (!(length(time) == 1 & is.numeric(time))) stop("time should be a single number")
N <- numeric(time+1)
Nt[1] <- N0
for (t in 1:time) {
Nt[t + 1] <- Nt[t] + r * Nt[t] * (1 - Nt[t] / K)
}
data.frame(time=0:time, Nt =N)
}
# Define molecular weights
MW_sucrose = 342.30  # g/mol
MW_glucose = 180.18  # g/mol
MW_ethanol = 46.08   # g/mol
MW_CO2 = 44.01       # g/mol
# Percentage of sucrose in molasses by weight
sucrose_content = 0.50
# Prompt user for amount of molasses used
molasses_mass_metric_tonne = float(input("Enter the amount of molasses used in metric tonnes: ")) * 1_000_000  # Convert to grams
reticulate::repl_python()
reticulate::source_python('~/eas501/Molasses.py')
reticulate::repl_python()
